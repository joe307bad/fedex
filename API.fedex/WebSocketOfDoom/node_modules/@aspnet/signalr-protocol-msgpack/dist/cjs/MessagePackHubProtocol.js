"use strict";
// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
var buffer_1 = require("buffer");
var msgpack5 = require("msgpack5");
var signalr_1 = require("@aspnet/signalr");
var BinaryMessageFormat_1 = require("./BinaryMessageFormat");
var MessagePackHubProtocol = /** @class */ (function () {
    function MessagePackHubProtocol() {
        this.name = "messagepack";
        this.version = 1;
        this.transferFormat = signalr_1.TransferFormat.Binary;
    }
    MessagePackHubProtocol.prototype.parseMessages = function (input, logger) {
        var _this = this;
        if (logger === null) {
            logger = signalr_1.NullLogger.instance;
        }
        return BinaryMessageFormat_1.BinaryMessageFormat.parse(input).map(function (m) { return _this.parseMessage(m, logger); });
    };
    MessagePackHubProtocol.prototype.parseMessage = function (input, logger) {
        if (input.length === 0) {
            throw new Error("Invalid payload.");
        }
        var msgpack = msgpack5();
        var properties = msgpack.decode(new buffer_1.Buffer(input));
        if (properties.length === 0 || !(properties instanceof Array)) {
            throw new Error("Invalid payload.");
        }
        var messageType = properties[0];
        switch (messageType) {
            case 1 /* Invocation */:
                return this.createInvocationMessage(this.readHeaders(properties), properties);
            case 2 /* StreamItem */:
                return this.createStreamItemMessage(this.readHeaders(properties), properties);
            case 3 /* Completion */:
                return this.createCompletionMessage(this.readHeaders(properties), properties);
            case 6 /* Ping */:
                return this.createPingMessage(properties);
            case 7 /* Close */:
                return this.createCloseMessage(properties);
            default:
                // Future protocol changes can add message types, old clients can ignore them
                logger.log(signalr_1.LogLevel.Information, "Unknown message type '" + messageType + "' ignored.");
                return null;
        }
    };
    MessagePackHubProtocol.prototype.createCloseMessage = function (properties) {
        // check minimum length to allow protocol to add items to the end of objects in future releases
        if (properties.length < 2) {
            throw new Error("Invalid payload for Close message.");
        }
        return {
            // Close messages have no headers.
            error: properties[1],
            type: 7 /* Close */,
        };
    };
    MessagePackHubProtocol.prototype.createPingMessage = function (properties) {
        // check minimum length to allow protocol to add items to the end of objects in future releases
        if (properties.length < 1) {
            throw new Error("Invalid payload for Ping message.");
        }
        return {
            // Ping messages have no headers.
            type: 6 /* Ping */,
        };
    };
    MessagePackHubProtocol.prototype.createInvocationMessage = function (headers, properties) {
        // check minimum length to allow protocol to add items to the end of objects in future releases
        if (properties.length < 5) {
            throw new Error("Invalid payload for Invocation message.");
        }
        var invocationId = properties[2];
        if (invocationId) {
            return {
                arguments: properties[4],
                headers: headers,
                invocationId: invocationId,
                target: properties[3],
                type: 1 /* Invocation */,
            };
        }
        else {
            return {
                arguments: properties[4],
                headers: headers,
                target: properties[3],
                type: 1 /* Invocation */,
            };
        }
    };
    MessagePackHubProtocol.prototype.createStreamItemMessage = function (headers, properties) {
        // check minimum length to allow protocol to add items to the end of objects in future releases
        if (properties.length < 4) {
            throw new Error("Invalid payload for StreamItem message.");
        }
        return {
            headers: headers,
            invocationId: properties[2],
            item: properties[3],
            type: 2 /* StreamItem */,
        };
    };
    MessagePackHubProtocol.prototype.createCompletionMessage = function (headers, properties) {
        // check minimum length to allow protocol to add items to the end of objects in future releases
        if (properties.length < 4) {
            throw new Error("Invalid payload for Completion message.");
        }
        var errorResult = 1;
        var voidResult = 2;
        var nonVoidResult = 3;
        var resultKind = properties[3];
        if (resultKind !== voidResult && properties.length < 5) {
            throw new Error("Invalid payload for Completion message.");
        }
        var completionMessage = {
            error: null,
            headers: headers,
            invocationId: properties[2],
            result: null,
            type: 3 /* Completion */,
        };
        switch (resultKind) {
            case errorResult:
                completionMessage.error = properties[4];
                break;
            case nonVoidResult:
                completionMessage.result = properties[4];
                break;
        }
        return completionMessage;
    };
    MessagePackHubProtocol.prototype.writeMessage = function (message) {
        switch (message.type) {
            case 1 /* Invocation */:
                return this.writeInvocation(message);
            case 4 /* StreamInvocation */:
                return this.writeStreamInvocation(message);
            case 2 /* StreamItem */:
            case 3 /* Completion */:
                throw new Error("Writing messages of type '" + message.type + "' is not supported.");
            default:
                throw new Error("Invalid message type.");
        }
    };
    MessagePackHubProtocol.prototype.writeInvocation = function (invocationMessage) {
        var msgpack = msgpack5();
        var payload = msgpack.encode([1 /* Invocation */, invocationMessage.headers || {}, invocationMessage.invocationId || null,
            invocationMessage.target, invocationMessage.arguments]);
        return BinaryMessageFormat_1.BinaryMessageFormat.write(payload.slice());
    };
    MessagePackHubProtocol.prototype.writeStreamInvocation = function (streamInvocationMessage) {
        var msgpack = msgpack5();
        var payload = msgpack.encode([4 /* StreamInvocation */, streamInvocationMessage.headers || {}, streamInvocationMessage.invocationId,
            streamInvocationMessage.target, streamInvocationMessage.arguments]);
        return BinaryMessageFormat_1.BinaryMessageFormat.write(payload.slice());
    };
    MessagePackHubProtocol.prototype.readHeaders = function (properties) {
        var headers = properties[1];
        if (typeof headers !== "object") {
            throw new Error("Invalid headers.");
        }
        return headers;
    };
    return MessagePackHubProtocol;
}());
exports.MessagePackHubProtocol = MessagePackHubProtocol;
//# sourceMappingURL=MessagePackHubProtocol.js.map